{"title":"vue-router底层实现原理","slug":"vue-router底层实现原理","date":"2021-07-20T13:08:42.000Z","updated":"2022-02-15T13:18:29.165Z","comments":true,"path":"api/articles/vue-router底层实现原理.json","photos":[],"link":"","excerpt":"什么是vue-router?定义： vue用来写路由一个插件。包括 router-link、router-view 两个组件， 其中 router-link 用于实现跳转，router-view 用于展示视图 ","covers":["/2021/07/20/vue-router%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/20190517095559229.png"],"content":"<p>什么是vue-router?</p>\n<p>定义： vue用来写路由一个插件。包括 router-link、router-view 两个组件， 其中 router-link 用于实现跳转，router-view 用于展示视图 </p>\n<span id=\"more\"></span>\n\n<h2 id=\"vue-router的两种模式\"><a href=\"#vue-router的两种模式\" class=\"headerlink\" title=\"vue-router的两种模式\"></a>vue-router的两种模式</h2><h3 id=\"hash模式\"><a href=\"#hash模式\" class=\"headerlink\" title=\"hash模式\"></a>hash模式</h3><p>hash模式背后的原理是onhashchange事件</p>\n<p>因为hash发生变化的url都会被浏览器记录下来，从而你会发现浏览器的前进后退都可以用了，同时点击后退时，页面字体颜色也会发生变化。这样一来，尽管浏览器没有请求服务器，但是页面状态和url一一关联起来，后来人们给它起了一个霸气的名字叫前端路由，成为了单页应用标配。</p>\n<p>在hash模式下，前端路由修改的是#中的信息，而浏览器请求时是不带它玩的，仅hash符号之前的url会被包含在请求中所以没有问题.</p>\n<h3 id=\"history模式\"><a href=\"#history模式\" class=\"headerlink\" title=\"history模式\"></a>history模式</h3><p>通过history api，我们丢掉了丑陋的#，但是它也有个毛病：<br>不怕前进，不怕后退，就怕刷新，f5，（如果服务器中没有相应的响应或者资源，会分分钟刷出一个404来。）,因为刷新是实实在在地去请求服务器的,不玩虚的。</p>\n<p> history模式下，前端的url必须和实际向后端发起请求的url一致，如<a href=\"http://abc.com/user/id,%E5%90%8E%E7%AB%AF%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E5%AF%B9user/id%E7%9A%84%E8%B7%AF%E7%94%B1%E5%A4%84%E7%90%86%EF%BC%8C%E5%B0%86%E8%BF%94%E5%9B%9E404%E9%94%99%E8%AF%AF%E3%80%82\">http://abc.com/user/id,后端如果没有对user/id的路由处理，将返回404错误。</a> </p>\n<h2 id=\"vue-router底层实现方式\"><a href=\"#vue-router底层实现方式\" class=\"headerlink\" title=\"vue-router底层实现方式\"></a>vue-router底层实现方式</h2><img src=\"/2021/07/20/vue-router%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/20190517095559229.png\" class>\n\n<h2 id=\"2-3执行-router-init-vm\"><a href=\"#2-3执行-router-init-vm\" class=\"headerlink\" title=\"2.3执行 router.init(vm)\"></a>2.3执行 <code>router.init(vm)</code></h2><p>router.init<br>然后来看 router 的 init 方法就干了哪些事情</p>\n<p>（注册了对地址变更的监听，history.setupListeners()）</p>\n<p>依旧是在 src/index.js 中：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* @flow */</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; install &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./install&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createMatcher &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./create-matcher&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; HashHistory, getHash &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./history/hash&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; HTML5History, getLocation &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./history/html5&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; AbstractHistory &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./history/abstract&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; inBrowser, supportsHistory &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./util/dom&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; assert &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./util/warn&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VueRouter</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"> init (app: any <span class=\"comment\">/* Vue component instance */</span>) &#123;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"> <span class=\"built_in\">this</span>.app = app</span><br><span class=\"line\"><span class=\"keyword\">const</span> history = <span class=\"built_in\">this</span>.history</span><br><span class=\"line\"><span class=\"keyword\">if</span> (history <span class=\"keyword\">instanceof</span> HTML5History) &#123;</span><br><span class=\"line\">    history.transitionTo(getLocation(history.base))</span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (history <span class=\"keyword\">instanceof</span> HashHistory) &#123;</span><br><span class=\"line\">     history.transitionTo(getHash(), <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">     <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&#x27;hashchange&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">     history.onHashChange()</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">history.listen(<span class=\"function\"><span class=\"params\">route</span> =&gt;</span> &#123;</span><br><span class=\"line\"> <span class=\"built_in\">this</span>.app._route = route</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到初始化主要就是给 app 赋值，针对于 HTML5History 和 HashHistory 特殊处理，因为在这两种模式下才有可能存在进入时候的不是默认页，需要根据当前浏览器地址栏里的 path 或者 hash 来激活对应的路由，此时就是通过调用 transitionTo 来达到目的；</p>\n<p>而且此时还有个注意点是针对于 HashHistory 有特殊处理，</p>\n<h3 id=\"2-3-1为什么不直接在初始化-HashHistory-的时候监听-hashchange-事件呢？\"><a href=\"#2-3-1为什么不直接在初始化-HashHistory-的时候监听-hashchange-事件呢？\" class=\"headerlink\" title=\"2.3.1为什么不直接在初始化 HashHistory 的时候监听 hashchange 事件呢？\"></a>2.3.1为什么不直接在初始化 HashHistory 的时候监听 hashchange 事件呢？</h3><p>答：这个是为了修复vuejs/vue-router#725这个 bug 而这样做的，</p>\n<p>原因是因为在初始化的时候如果此时的 hash 值不是以 / 开头的话就会补上 #/，这个过程会触发 hashchange 事件，所以会再走一次生命周期钩子，也就意味着会再次调用 beforeEnter 钩子函数。即beforeEnter 钩子就会被触发两次。</p>\n<h3 id=\"2-3-2transitionTo-方法的大概逻辑\"><a href=\"#2-3-2transitionTo-方法的大概逻辑\" class=\"headerlink\" title=\"2.3.2transitionTo 方法的大概逻辑\"></a>2.3.2transitionTo 方法的大概逻辑</h3><p>在 src/history/base.js 中：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* @flow */</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> type VueRouter <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../index&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; warn &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../util/warn&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; inBrowser &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../util/dom&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; runQueue &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../util/async&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; START, isSameRoute &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../util/route&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; _Vue &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../install&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">History</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"> transitionTo (location: RawLocation, cb?: <span class=\"built_in\">Function</span>) &#123;</span><br><span class=\"line\"> <span class=\"comment\">// 调用 match 得到匹配的 route 对象</span></span><br><span class=\"line\"> <span class=\"keyword\">const</span> route = <span class=\"built_in\">this</span>.router.match(location, <span class=\"built_in\">this</span>.current)</span><br><span class=\"line\"> <span class=\"comment\">// 确认过渡</span></span><br><span class=\"line\"> <span class=\"built_in\">this</span>.confirmTransition(route, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\"> <span class=\"comment\">// 更新当前 route 对象</span></span><br><span class=\"line\"> <span class=\"built_in\">this</span>.updateRoute(route)</span><br><span class=\"line\"> cb &amp;&amp; cb(route)</span><br><span class=\"line\"> <span class=\"comment\">// 子类实现的更新url地址</span></span><br><span class=\"line\"> <span class=\"comment\">// 对于 hash 模式的话 就是更新 hash 的值</span></span><br><span class=\"line\"> <span class=\"comment\">// 对于 history 模式的话 就是利用 pushstate / replacestate 来更新</span></span><br><span class=\"line\"> <span class=\"comment\">// 浏览器地址</span></span><br><span class=\"line\"> <span class=\"built_in\">this</span>.ensureURL()</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>2.hashchange 或者路由跳转时，执行 history.transitionTo(…)，在这个过程中，会进行地址匹配，得到一个对应当前地址的 route，然后将其设置到对应的 vm._route上。updateRoute.﻿</p>\n<p>只是进行了赋值，</p>\n<h3 id=\"2-3-3为什么-vm-就可以感知到路由的改变了呢？\"><a href=\"#2-3-3为什么-vm-就可以感知到路由的改变了呢？\" class=\"headerlink\" title=\"2.3.3为什么 vm 就可以感知到路由的改变了呢？\"></a>2.3.3为什么 vm 就可以感知到路由的改变了呢？</h3><p>答案在 vue-router 注入 Vue 的 beforeCreate 钩子函数中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.util.defineReactive(this, &#x27;_route&#x27;, this._router.history.current)</span><br></pre></td></tr></table></figure>\n\n<p>采用与 Vue 本身数据相同的“数据劫持”方式，这样对 vm._route 的赋值会被 Vue 拦截到，并且触发 Vue 组件的更新渲染流程。</p>\n<h2 id=\"2-4视图更新\"><a href=\"#2-4视图更新\" class=\"headerlink\" title=\"2.4视图更新\"></a>2.4视图更新</h2><p>地址变更如何同步视图更新？</p>\n<p>接上一步，vm._route 已经接收到路由的变更，从而触发视图更新。而当视图更新进一步调用到 <router-view> 的 render() 时，即进入了 <router-view> 的处理。</router-view></router-view></p>\n<p><router-view> 的 render() 采用函数调用（h()）模式，而非通过模板生成。这也是 Vue2 支持的定义组件渲染逻辑的方式，类似 React 的 render()。</router-view></p>\n<p>采用这种模式的好处是</p>\n<p>可以完全利用 JavaScript 的能力来编写逻辑，不必受制于 Vue 的类 HTML 模板语法。</p>\n<p>这里的主要处理逻辑是从根组件中取出当前的路由对象（parent.$route），然后取得该路由下对应的组件，然后交由该组件进行渲染：</p>\n<p>return h(component, data, children)</p>\n<p>这其中还涉及 <router-view> 嵌套的处理，不过主要逻辑就是这样了。</router-view></p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><blockquote>\n<p>vue-router 以插件方式“侵入”Vue，从而支持一个额外的 router 属性，以提供监听并改变组件路由数据的能力。这样每次路由发生改变后，可以同步到数据，进而“响应式”地触发组件的更新。</p>\n<p><router-view> 作为根组件下的子组件，从根组件那里可以获取到当前的路由对象，进而根据路由对象的组件配置，取出组件并用其替换当前位置的内容。这样，也就完成整个路由变更到视图变更的过程。</router-view></p>\n</blockquote>\n<p> ① 路由变更到视图变更的过程整理为： </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hashchange</span><br><span class=\"line\">--&gt;</span><br><span class=\"line\">match route</span><br><span class=\"line\">--&gt;</span><br><span class=\"line\">set vm._route</span><br><span class=\"line\">--&gt;</span><br><span class=\"line\">&lt;router-view&gt; render()</span><br><span class=\"line\">--&gt;</span><br><span class=\"line\">render matched component</span><br></pre></td></tr></table></figure>\n\n<p>② 实现过程中的技术点包括：</p>\n<ul>\n<li>Vue 插件机制</li>\n<li>响应式数据机制</li>\n<li>Vue 渲染机制</li>\n<li>地址变更监听</li>\n</ul>\n","categories":[],"tags":[{"name":"vue3 vue-router","slug":"vue3-vue-router","count":1,"path":"api/tags/vue3-vue-router.json"}]}