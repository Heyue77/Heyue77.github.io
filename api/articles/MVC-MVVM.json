{"title":"MVC/MVVM","slug":"MVC-MVVM","date":"2021-02-15T12:18:42.000Z","updated":"2022-02-15T12:29:18.461Z","comments":true,"path":"api/articles/MVC-MVVM.json","photos":[],"link":"","excerpt":"简单介绍前端MVC/MVVM模式特点及区别","covers":["/2021/02/15/MVC-MVVM/20220215202152.png","/2021/02/15/MVC-MVVM/20220215202406.png"],"content":"<h1 id=\"简单介绍前端MVC-MVVM模式特点及区别\"><a href=\"#简单介绍前端MVC-MVVM模式特点及区别\" class=\"headerlink\" title=\"简单介绍前端MVC/MVVM模式特点及区别\"></a>简单介绍前端MVC/MVVM模式特点及区别</h1><span id=\"more\"></span>\n\n<h2 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一.概述\"></a>一.概述</h2><p>MVC,MVP,MVVM是三种常见的前端架构模式(Architectural Pattern),它通过分离关注点来改进代码组织方式。不同于设计模式(Design Pattern),只是为了解决一类问题而总结出的抽象方法，一种架构模式往往能使用多种设计模式。</p>\n<p>MVC模式是MVP,MVVM模式的基础，这两种模式更像是MVC模式的优化改良版,他们三个的MV即Model，view相同，不同的是MV之间的纽带部分。本文主要介绍MVC与MVVM的应用与区别，因为MVP好像不是很常用。</p>\n<h2 id=\"二-MVC\"><a href=\"#二-MVC\" class=\"headerlink\" title=\"二.MVC\"></a>二.MVC</h2><p>简介一下MVC：</p>\n<img src=\"/2021/02/15/MVC-MVVM/20220215202152.png\" class>\n\n<p>MVC允许在不改变视图的情况下改变视图对用户输入的响应方式，用户对View的操作交给了Controller处理，在Controller中响应View的事件调用Model的接口对数据进行操作，一旦Model发生变化便通知相关视图进行更新。</p>\n<p>如果前端没有框架，只使用原生的html+js，MVC模式可以这样理解。将html看成view;js看成controller，负责处理用户与应用的交互，响应对view的操作（对事件的监听），调用Model对数据进行操作，完成model与view的同步（根据model的改变，通过选择器对view进行操作）;将js的ajax当做Model，也就是数据层，通过ajax从服务器获取数据。</p>\n<p>按照上面这种方式分层，感觉多少有点强行MVC，因为Model层被弱化了。我们可以看看其他主流MVC框架是怎么分层的，拿BackBone举例。</p>\n<p>首先简单介绍一下backbone，它是一个轻量级前端MVC框架，用于结构化管理页面中大量的js（就是管理大量js文件的项目更适用），建立与服务器，视图间的无缝连接，为构建复杂应用提供基础架构。backbone里面包含Model，View，Collection，Router等模块。这里的Model和View与MVC模式的Model和View有区别，我们先看Model。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> M = Backbone.Model.extend(&#123;  </span><br><span class=\"line\"> </span><br><span class=\"line\">　　<span class=\"attr\">defaults</span>:&#123;<span class=\"attr\">name</span>:<span class=\"string\">&quot;hello&quot;</span>&#125; ,</span><br><span class=\"line\"> </span><br><span class=\"line\">　　<span class=\"attr\">initialize</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;   <span class=\"comment\">//new M时，会执行这个初始化函数。</span></span><br><span class=\"line\"> </span><br><span class=\"line\">　　　　<span class=\"built_in\">this</span>.on(<span class=\"string\">&quot;change&quot;</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;   <span class=\"comment\">//监听change事件</span></span><br><span class=\"line\"> </span><br><span class=\"line\">　　　　　　alert(<span class=\"number\">1</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">　　　　&#125;)</span><br><span class=\"line\"> </span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">var</span> model = <span class=\"keyword\">new</span> M();</span><br><span class=\"line\"> </span><br><span class=\"line\">model.set(<span class=\"string\">&quot;name&quot;</span>,<span class=\"string\">&quot;hi&quot;</span>);    <span class=\"comment\">//改变模型的name值时，就会触发change事件，弹出1.其实这里只要改变模型，就会触发。</span></span><br></pre></td></tr></table></figure>\n\n<p>这里Model的对象不只包含数据，也有对属性（name）的监听事件。所以backbone里的Model也不是纯Model，它有一部分Controller的功能。</p>\n<p>我们再看看Backbone的View</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> M = Backbone.Model.extend(&#123;  </span><br><span class=\"line\"> </span><br><span class=\"line\">　　<span class=\"attr\">defaults</span>:&#123;<span class=\"attr\">name</span>:<span class=\"string\">&quot;hello&quot;</span>&#125; 　</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">var</span> V = Backbone.View.extend(&#123;  </span><br><span class=\"line\"> </span><br><span class=\"line\">　　<span class=\"attr\">initialize</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;   <span class=\"comment\">//new V时，会跟这个视图的model绑定change事件，回调方法是视图的show方法</span></span><br><span class=\"line\"> </span><br><span class=\"line\">　　　　<span class=\"built_in\">this</span>.listenTo(<span class=\"built_in\">this</span>.model, <span class=\"string\">&quot;change&quot;</span>, <span class=\"built_in\">this</span>.show);   <span class=\"comment\">//listenTo方法跟on一样是绑定事件的，但是listenTo可以设置this的指向，它多一个参数。它的意思就是：给this.model绑定change事件。</span></span><br><span class=\"line\"> </span><br><span class=\"line\">　　&#125;,</span><br><span class=\"line\"> </span><br><span class=\"line\">　　<span class=\"attr\">show</span>:<span class=\"function\"><span class=\"title\">funtion</span>(<span class=\"params\">model</span>)</span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">　　　　$(<span class=\"string\">&quot;#tt&quot;</span>).append(<span class=\"built_in\">this</span>.model.name);</span><br><span class=\"line\"> </span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">var</span> m= <span class=\"keyword\">new</span> M();</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">var</span> v = <span class=\"keyword\">new</span> V(&#123;<span class=\"attr\">model</span>:m&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">m.set(<span class=\"string\">&quot;name&quot;</span>,<span class=\"string\">&quot;hi&quot;</span>);    <span class=\"comment\">//改变模型的name值时，就会触发change事件，在视图中弹出模型设置的name值。</span></span><br></pre></td></tr></table></figure>\n\n<p>这里view即包含了视图显示也包含了事件监听，属于传统的View+Model。</p>\n<p>综上可以看出，backbone这样的MVC框架，Model和View的概念很突出，Controller主要放在了View里面。这种模式更好理解，Model看成模型，View看成这个模型的视图化体现，而Controller根据需要写在各自的方法里。这么一看MVC还是挺好的，那为什么有MVVM这种改良版本呢？</p>\n<h2 id=\"三-MVVM\"><a href=\"#三-MVVM\" class=\"headerlink\" title=\"三.MVVM\"></a>三.MVVM</h2><img src=\"/2021/02/15/MVC-MVVM/20220215202406.png\" class>\n\n<p>  MVVM与MVC最大的区别就是：它实现了View和Model的自动同步，也就是当Model的属性改变时，我们不用再自己手动操作Dom元素，来改变View的显示，而是改变属性后该属性对应View层显示会自动改变。非常的神奇~</p>\n<p>这里我们拿典型的MVVM模式的代表，Vue，来举例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app-5&quot;&gt;</span><br><span class=\"line\">  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">  &lt;button v-on:click=&quot;reverseMessage&quot;&gt;逆转消息&lt;/button&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app5 = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">&#x27;#app-5&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Hello Vue.js!&#x27;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">reverseMessage</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.message = <span class=\"built_in\">this</span>.message.split(<span class=\"string\">&#x27;&#x27;</span>).reverse().join(<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p> 这里的html部分相当于View层，可以看到这里的View通过通过模板语法来声明式的将数据渲染进DOM元素，当ViewModel对Model进行更新时，通过数据绑定更新到View。</p>\n<p>Vue实例中的data相当于Model层，而ViewModel层的核心是Vue中的双向数据绑定，即Model变化时VIew可以实时更新，View变化也能让Model发生变化。</p>\n<p>整体看来，MVVM比MVC精简很多，不仅简化了业务与界面的依赖，还解决了数据频繁更新的问题，不用再用选择器操作DOM元素。因为在MVVM中，View不知道Model的存在，Model和ViewModel也观察不到View，这种低耦合模式提高代码的可重用性。</p>\n<h2 id=\"四-总结\"><a href=\"#四-总结\" class=\"headerlink\" title=\"四.总结\"></a>四.总结</h2><p>在学习MVC与MVVM架构模式的过程中，经常会对分层的界限叫不准。比如说不清楚js里到底哪里算Model，哪里算Controller，Vue实例里面Model与ViewModel的严格界限在哪，有时候越想越感觉叫不准。当我从头到尾整理完这两种模式特点的时候，发现这个界限没有那么重要。我觉得重要的是，理解两种模式的基本思想，根据应用需求，选择适合自己业务的框架。MVVM自然有很多先进的地方，但有的项目选择BackBone可能会更适合。在实践中比较两种模式的各个框架的优缺点，选择适合自己的架构模式，更有利于项目的高效开发。</p>\n","categories":[],"tags":[{"name":"vue3","slug":"vue3","count":2,"path":"api/tags/vue3.json"}]}