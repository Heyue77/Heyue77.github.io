{"title":"为什么要使用vue3","slug":"vue2与vue3的区别","date":"2021-07-15T12:29:04.000Z","updated":"2022-02-15T12:55:05.282Z","comments":true,"path":"api/articles/vue2与vue3的区别.json","photos":[],"link":"","excerpt":"Vue 3尚未正式发布，但是维护者已经发布了Beta版本，供我们的参与者尝试并提供反馈。下面将介绍一下Vue 3的主要功能和主要变化是什么，包括fragments，teleport，Composition API以及其他一些晦涩的更改写下自己的理解。","covers":["/2021/07/15/vue2%E4%B8%8Evue3%E7%9A%84%E5%8C%BA%E5%88%AB/20220215203445.png"],"content":"<p>Vue 3尚未正式发布，但是维护者已经发布了Beta版本，供我们的参与者尝试并提供反馈。</p>\n<p>下面将介绍一下Vue 3的主要功能和主要变化是什么，包括fragments，teleport，Composition API以及其他一些晦涩的更改写下自己的理解。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"我们将建立什么\"><a href=\"#我们将建立什么\" class=\"headerlink\" title=\"我们将建立什么\"></a>我们将建立什么</h2><p>我们将构建一个带有模式窗口功能的简单应用。我之所以选择它，是因为它可以方便地展示Vue 3的许多变化。</p>\n<p>这是该应用在打开和关闭状态下的外观，因此你可以在脑海中描绘出我们正在做什么：</p>\n<img src=\"/2021/07/15/vue2%E4%B8%8Evue3%E7%9A%84%E5%8C%BA%E5%88%AB/20220215203445.png\" class>\n\n<p>Vue 3安装和setup<br>与其直接安装Vue 3，不如克隆一个项目 vue-next-webpack-preview，这将为我们提供一个包括Vue 3在内的最小的Webpack设置。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone https:<span class=\"comment\">//github.com/vuejs/vue-next-webpack-preview.git vue3-experiment</span></span><br><span class=\"line\">$ cd vue3-experiment</span><br><span class=\"line\">$ npm i</span><br></pre></td></tr></table></figure>\n\n\n<p>一旦克隆好了，安装好了NPM模块，我们需要做的就是删除样板文件，然后创建一个新的 main.js 文件，这样我们就可以从头开始创建我们的Vue 3 app了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rm -rf src<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">$ touch src/main.js</span></span><br></pre></td></tr></table></figure>\n\n\n<p>现在，我们将运行开发服务器：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm run dev</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建一个新的Vue-3-app\"><a href=\"#创建一个新的Vue-3-app\" class=\"headerlink\" title=\"创建一个新的Vue 3 app\"></a>创建一个新的Vue 3 app</h2><p>我们启动一个新的Vue应用程序的方式改变了，我们现在需要导入新的 createApp 方法，而不是使用新的 Vue()。</p>\n<p>我们调用这个方法，传递我们的Vue实例定义对象，并将返回对象分配给一个变量 app。</p>\n<p>接下来，我们将在 app 上调用 mount 方法，并传递一个CSS选择器来指示我们的mount元素，就像在Vue 2中使用 $mount 实例方法一样。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/main.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createApp &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;vue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = createApp(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 根实例定义</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.mount(<span class=\"string\">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"变化的原因\"><a href=\"#变化的原因\" class=\"headerlink\" title=\"变化的原因\"></a>变化的原因</h2><p>与旧的API一样，我们添加的任何全局配置（plugins，mixins，原型属性等）都将永久更改全局状态。例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/main.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 影响两个实例</span></span><br><span class=\"line\">Vue.mixin(&#123; ... &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app1 = <span class=\"keyword\">new</span> Vue(&#123; <span class=\"attr\">el</span>: <span class=\"string\">&#x27;#app-1&#x27;</span> &#125;)</span><br><span class=\"line\"><span class=\"keyword\">const</span> app2 = <span class=\"keyword\">new</span> Vue(&#123; <span class=\"attr\">el</span>: <span class=\"string\">&#x27;#app-2&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>\n\n\n<p>在单元测试中，这确实是一个问题，因为要确保将每个测试都与上一个测试隔离是很棘手的。</p>\n<p>在新的API下，调用 createApp 将返回一个新的app实例，该实例不会被应用于其他实例的任何全局配置污染。</p>\n<blockquote>\n<p> 了解更多：<a href=\"https://github.com/vuejs/rfcs/blob/master/active-rfcs/0009-global-api-change.md\">Global API change RFC</a>。 </p>\n</blockquote>\n<h2 id=\"添加state属性\"><a href=\"#添加state属性\" class=\"headerlink\" title=\"添加state属性\"></a>添加state属性</h2><p>我们的模态窗口可以处于两种状态之一——打开或关闭。让我们用一个布尔状态属性 modalOpen 来管理它，我们将给它一个初始值 false。</p>\n<p>在Vue 2下，我们可以通过在我们的应用实例上创建一个 data 属性并将一个对象分配给该对象来声明 modalOpen 属性，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/main.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = createApp(&#123;</span><br><span class=\"line\">  <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">modalOpen</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<p>不再允许这样做。相反，必须为数据分配一个返回状态对象的工厂函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/main.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = createApp(&#123;</span><br><span class=\"line\">  <span class=\"attr\">data</span>: <span class=\"function\">() =&gt;</span> (&#123;</span><br><span class=\"line\">    <span class=\"attr\">modalOpen</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"变化的原因-1\"><a href=\"#变化的原因-1\" class=\"headerlink\" title=\"变化的原因\"></a>变化的原因</h2><p>使用对象而不是工厂函数来存储数据的优点是，首先，它在语法上更简单；其次，你可以在多个根实例之间共享顶级状态，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/main.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> state = &#123;</span><br><span class=\"line\">  <span class=\"attr\">sharedVal</span>: <span class=\"number\">0</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app1 = <span class=\"keyword\">new</span> Vue(&#123; state &#125;);</span><br><span class=\"line\"><span class=\"keyword\">const</span> app2 = <span class=\"keyword\">new</span> Vue(&#123; state &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 影响两个实例</span></span><br><span class=\"line\">app1._data.sharedVal = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这种用例很少，可以使用。因为有两种类型的声明是不适合初学者的，所以决定删除这个特性。</p>\n<p>了解更多：Data object declaration removed RFC</p>\n<p>在继续之前，我们还添加一个方法来切换 modalOpen 值。这与Vue 2没什么不同。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/main.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = createApp(&#123;</span><br><span class=\"line\">  <span class=\"attr\">data</span>: <span class=\"function\">() =&gt;</span> (&#123;</span><br><span class=\"line\">    <span class=\"attr\">modalOpen</span>: <span class=\"literal\">true</span>  </span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">  <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">toggleModalState</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.modalOpen = !<span class=\"built_in\">this</span>.modalOpen;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用一个根组件\"><a href=\"#使用一个根组件\" class=\"headerlink\" title=\"使用一个根组件\"></a>使用一个根组件</h2><p>如果你现在进入浏览器并检查控制台，则会看到警告“Component is missing render function”，因为我们尚未为根实例定义模板。</p>\n<p>Vue 2的最佳实践是为根实例创建一个最小的模板，并创建一个app组件，其中将声明主app标记。</p>\n<p>让我们在这里也这样做。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ touch src/App.vue</span><br></pre></td></tr></table></figure>\n\n<p>现在我们可以获取根实例来渲染该组件。区别在于，对于Vue 2，我们通常会使用render函数来执行此操作：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/main.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">&quot;./App.vue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = createApp(&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"params\">h</span> =&gt;</span> h(App)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.mount(<span class=\"string\">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n\n<p>我们仍然可以做到这一点，但是Vue 3有一个更简单的方法——使 App 成为根组件。为此，我们可以删除根实例定义，而是传递 App 组件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/main.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">&quot;./App.vue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = createApp(App);</span><br><span class=\"line\"></span><br><span class=\"line\">app.mount(<span class=\"string\">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这意味着 App 组件不仅由根实例渲染，而且是根实例。</p>\n<p>在此过程中，我们通过删除 app 变量来简化语法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// src/main.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">createApp(App).mount(<span class=\"string\">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>现在移至根组件，让我们向该组件重新添加状态和方法：</p>\n<p>// src/App.vue</p>\n<script>\nexport default {\n  data: () => ({\n    modalOpen: true  \n  }),\n  methods: {\n    toggleModalState() {\n      this.modalOpen = !this.modalOpen;\n    }\n  }\n};\n</script>\n\n\n<p>我们还为模态功能创建一个新组件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ touch src/Modal.vue</span><br></pre></td></tr></table></figure>\n\n<p>现在，我们将提供一个最小的模板，其中包括内容插槽。这确保了我们的模态是可重用的。稍后我们将向此组件添加更多内容。</p>\n<p>// src/Modal.vue<br><template><br>  <div class=\"modal\"><br>    <slot></slot><br>  </div><br></template></p>\n<h2 id=\"多根模板\"><a href=\"#多根模板\" class=\"headerlink\" title=\"多根模板\"></a>多根模板</h2><p>现在让我们为我们的根组件创建模板。我们将创建一个按钮来打开模态，它将触发 toggleModalState 方法。</p>\n<p>我们还将使用我们刚刚创建的modal组件，它将根据 modalState 的值来渲染。让我们也在槽中插入一段文字作为内容。</p>\n<p>// src/App.vue<br><template><br>  &lt;button @click=”toggleModalState”&gt;Open modal<br>  <modal v-if=\"modalOpen\"><br>    <p>Hello, I’m a modal window.</p><br>  </modal><br></template></p>\n<script>\nimport Modal from \"./Modal.vue\";\nexport default {\n  components: {\n    Modal\n  },\n  ...\n}\n</script>\n\n\n<p>注意这个模板有什么奇怪的地方吗？再看一遍。</p>\n<p>没错——有两个根元素。在Vue 3中，由于有了一个叫做片段（fragments）的功能，它不再强制要求有一个单一的根元素！</p>\n<h3 id=\"使用Composition-API进行重构\"><a href=\"#使用Composition-API进行重构\" class=\"headerlink\" title=\"使用Composition API进行重构\"></a>使用Composition API进行重构</h3><p>Vue 3的旗舰功能是Composition API。这个新的API允许你使用 setup 功能而不是使用添加到组件定义对象的属性来定义组件功能。</p>\n<p>现在，让我们重构App组件以使用Composition API。</p>\n<p>在解释代码之前，请清楚我们所做的只是重构——组件的功能将相同。还要注意，模板没有更改，因为Composition API仅影响我们定义组件功能的方式，而不影响我们渲染它的方式。</p>\n<p>src/App.vue<br><template><br>  &lt;button @click=”toggleModalState”&gt;Open modal<br>  <modal v-if=\"modalOpen\"><br>    <p>Hello, I’m a modal window.</p><br>  </modal><br></template></p>\n<script>\nimport Modal from \"./Modal.vue\";\nimport { ref } from \"vue\";\nexport default {\n  setup () {\n    const modalState = ref(false);\n    const toggleModalState = () => {\n      modalState.value = !modalState.value;\n    };\n    return {\n      modalState,\n      toggleModalState\n    }\n  }\n};\n</script>\n\n<h2 id=\"setup-方法\"><a href=\"#setup-方法\" class=\"headerlink\" title=\"setup 方法\"></a>setup 方法</h2><p>首先，请注意，我们导入了 ref 函数，该函数允许我们定义响应式变量 modalState。此变量等效于this.modalState。</p>\n<p>toggleModalState 方法只是一个普通的JavaScript函数。但是，请注意，要更改方法主体中的 modalState 值，我们需要更改其子属性 value。 这是因为使用 ref 创建的响应式变量被封装在一个对象中。这对于保留它们的响应式是非常必要的，因为它们在被传递的过程中会被保留下来。</p>\n<p>最后，我们从 setup 方法返回 modalState 和 toggleModalState ，因为这些是在呈现模板时传递给模板的值。</p>\n<h2 id=\"变化的原因-2\"><a href=\"#变化的原因-2\" class=\"headerlink\" title=\"变化的原因\"></a>变化的原因</h2><p>请记住，Composition API并不是更改，因为它纯粹是可选的。主要动机是允许更好的代码组织和组件之间的代码重用（因为mixin本质上是一种反模式）。</p>\n<p>如果你认为在这个例子中重构App组件以使用Composition API是没有必要的，那你的想法是正确的。但是，如果这是一个更大的组件，或者我们需要与其他组件共享其功能，那么你就会发现它的用处。</p>\n<p>Teleporting content<br>如果你曾经创建过模态功能，你会知道它通常被放置在关闭的  标签之前。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--main page content here--&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!--modal here--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这样做是因为模式通常具有覆盖页面的背景，要使用CSS来实现，您不需要处理父元素定位和z-index堆栈上下文，因此最简单的解决方案是将模式放在DOM的最底部。</p>\n<p>但这在Vue.js中产生了一个问题，它假定UI将作为一个单一的组件树来构建。为了允许将树的片段移动到DOM中的其他位置，在Vue 3中添加了一个新的 teleport 组件。</p>\n<p>要使用teleport，首先要在页面上添加一个元素，我们要将模态内容移动到该页面。我们将转到 index.html，并将ID为 modal-wrapper 的 div 放在Vue的安装元素旁边。</p>\n<p>index.html</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span><span class=\"comment\">&lt;!--Vue mounting element--&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;modal-wrapper&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--modal should get moved here--&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>现在，回到 <code>App.vue</code>，我们将模态内容包装在 <code>teleport</code> 组件中。我们还需要指定一个 <code>to</code> 属性，为该属性分配一个查询选择器，以标识目标元素，在本例中为 <code>#modal-wrapper</code>。</p>\n<p>src/App.vue</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;button @click=&quot;toggleModalState&quot;&gt;Open modal&lt;/button&gt;</span><br><span class=\"line\">  &lt;teleport to=&quot;#modal-wrapper&quot;&gt;</span><br><span class=\"line\">    &lt;modal v-if=&quot;modalOpen&quot;&gt;</span><br><span class=\"line\">      &lt;p&gt;Hello, I&#x27;m a modal window.&lt;/p&gt;</span><br><span class=\"line\">    &lt;/modal&gt;</span><br><span class=\"line\">  &lt;/teleport&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>就是这样，teleport 中的任何内容都将渲染在目标元素中。</p>\n<h2 id=\"Emitting-和-event\"><a href=\"#Emitting-和-event\" class=\"headerlink\" title=\"Emitting 和 event\"></a>Emitting 和 event</h2><p>现在，让我们在modal中添加一个按钮，让它可以被关闭。要做到这一点，我们要在modal 模板中添加一个按钮元素，并添加一个点击处理程序，该处理程序会发出一个 close 事件。</p>\n<p>src/Modal.vue</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;modal&quot;&gt;</span><br><span class=\"line\">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;$emit(&#x27;close&#x27;)&quot;&gt;Dismiss&lt;/button&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>然后，该事件将由父组件捕获，并将切换 <code>modalState</code> 的值，从逻辑上将其设置为 <code>false</code> 并导致窗口关闭。</p>\n<p>src/App.vue</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">modal</span> </span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">v-if</span>=<span class=\"string\">&quot;modalOpen&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">      @<span class=\"attr\">click</span>=<span class=\"string\">&quot;toggleModalState&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    &gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Hello, I&#x27;m a modal window.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">modal</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">teleport</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>到目前为止，此功能与Vue 2中的功能相同。但是，现在在Vue 3中，建议您使用新的 <code>emits</code> 组件选项显式声明组件的事件。就像props一样，你可以简单地创建一个字符串数组来命名组件将发出的每个事件。</p>\n<p>src/Modal.vue</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"attr\">emits</span>: [ <span class=\"string\">&quot;close&quot;</span> ]</span></span><br><span class=\"line\"><span class=\"javascript\">&#125;</span></span><br><span class=\"line\"><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"变化的原因-3\"><a href=\"#变化的原因-3\" class=\"headerlink\" title=\"变化的原因\"></a>变化的原因</h3><p>想象一下，打开别人写的组件的文件，看到它的prop和event明文声明。马上，你就会明白这个组件的界面，也就是它要发送和接收什么。</p>\n<p>除了提供自说明代码外，你还可以使用事件声明来验证你的事件有效载荷，虽然我在这个例子中找不到理由来验证。</p>\n<blockquote>\n<p> 了解更多：<a href=\"https://github.com/vuejs/rfcs/blob/master/active-rfcs/0030-emits-option.md\">Emits Option RFC</a> </p>\n</blockquote>\n<p>样式插槽内容<br>为了使模态可重用，我们提供了一个内容插槽。让我们开始通过为组件添加 style 标签来为内容设置样式。</p>\n<p>在我们的组件中使用 scoped CSS是一种很好的做法，以确保我们提供的规则不会对页面中的其他内容产生意外影响。</p>\n<p>让我们把任何被放入插槽中的段落文字变成斜体。要做到这一点，我们将使用 p 选择器创建一个新的CSS规则。</p>\n<p>src/Modal.vue</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;...&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;...&lt;/script&gt;</span><br><span class=\"line\">&lt;style scoped&gt;</span><br><span class=\"line\">  p &#123;</span><br><span class=\"line\">    font-style: italic;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>如果你尝试一下，你会发现这一点并不奏效。问题是，在编译时，当插槽内容仍属于父对象时，Scoped styling是在编译时确定的。</p>\n<p>Vue 3提供的解决方案是提供一个伪选择器 <code>::v-slotted()</code>，允许你在提供插槽的组件中使用范围化规则来针对插槽内容。</p>\n<p>这是我们的用法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style scoped&gt;</span><br><span class=\"line\">  ::v-slotted(p) &#123;</span><br><span class=\"line\">    font-style: italic;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Vue 3还包含了其他一些新的Scoped Styling选择器：::v-deep 和 ::v-global，你可以在这里了解更多：Scoped Styles RFC。</p>\n<p>其他改变<br>好吧，这就是我可以在一个简单示例中涵盖的所有新功能。主要的我基本都有了，但这里有一些我认为很重要的，在总结文章之前，我觉得足够重要，可以自己研究一下。</p>\n<p>添加的：</p>\n<ul>\n<li>Global API treeshaking</li>\n</ul>\n<p>移出的：</p>\n<ul>\n<li>Filters</li>\n<li>Inline templates</li>\n<li>Event interface for components（不再有event bus）</li>\n</ul>\n<p>更改的：</p>\n<ul>\n<li>Async component API</li>\n<li>Custom directive API</li>\n<li>Render function syntax</li>\n</ul>\n<p> 关于Vue Router也有各种变化，下次有时间再整理！</p>\n","categories":[],"tags":[{"name":"vue2,vue3","slug":"vue2-vue3","count":1,"path":"api/tags/vue2-vue3.json"}]}